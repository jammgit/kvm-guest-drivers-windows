From 97d70f1b1dda2134dca1439b5408b52a70c9c0ac Mon Sep 17 00:00:00 2001
From: Colin Xu <colin.xu@intel.com>
Date: Wed, 6 Jan 2021 15:08:05 +0800
Subject: [PATCH 1/2] Add multi-touch tablet support.

The original ST support as stylus remains unchange except using the new
HID report layout.
Below new features are added:
- Change HID report layout to allow multi-touch contacts reported in
hybrid mode.
  The memory layout of the report:
   - 1 byte for report ID.
   - 7 bytes for each contact.
   - 1 byte for contact count to report.
   - 4 bytes for scan time.
+---------------+-+-+-+-+-+---------------+----------+------------+
| Byte Offset   |7|6|5|4|3|     2         |    1     |     0      |
+---------------+-+-+-+-+-+---------------+----------+------------+
| 0             |                    Report ID                    |
| i*7+1         |   Pad   | Barrel Switch | In-range | Tip Switch |
| i*7+[2,3]     |                    Contact ID                   |
| i*7+[4,5]     |                      x-axis                     |
| i*7+[6,7]     |                      y-axis                     |
| (i+1)*7+[1,7] |                   Contact i+1                   |
| (i+2)*7+[1,7] |                   Contact i+2                   |
| ...           |                                                 |
| (n-1)*7+[1,7] |                   Contact n-1                   |
| n*7+1         |                  Contact Count                  |
| n*7+[2,5]     |                    Scan Time                    |
+---------------+-+-+-+-+-+------------+----------+---------------+
- Report the maximum contacts via IOCTL_HID_GET_FEATURE.
- Support anonymous MT and identifiable MT depending on back-end.
- Support MSC_TIMESTAMP depending on back-end.

Signed-off-by: Colin Xu <colin.xu@intel.com>
---
 vioinput/sys/Hid.c       |  60 +++-
 vioinput/sys/Hid.h       |   6 +
 vioinput/sys/HidTablet.c | 670 ++++++++++++++++++++++++++++++++++-----
 vioinput/sys/vioinput.h  |  31 +-
 4 files changed, 682 insertions(+), 85 deletions(-)

diff --git a/vioinput/sys/Hid.c b/vioinput/sys/Hid.c
index 1080aa86..84fef69e 100644
--- a/vioinput/sys/Hid.c
+++ b/vioinput/sys/Hid.c
@@ -160,6 +160,44 @@ EvtIoDeviceControl(
         }
         break;
 
+    case IOCTL_HID_GET_FEATURE:
+        TraceEvents(TRACE_LEVEL_VERBOSE, DBG_IOCTLS, "IOCTL_HID_GET_FEATURE\n");
+
+        WDF_REQUEST_PARAMETERS_INIT(&params);
+        WdfRequestGetParameters(Request, &params);
+
+        if (params.Parameters.DeviceIoControl.OutputBufferLength < sizeof(HID_XFER_PACKET))
+        {
+            status = STATUS_BUFFER_TOO_SMALL;
+        }
+        else
+        {
+            PHID_XFER_PACKET pFeaturePkt = (PHID_XFER_PACKET)WdfRequestWdmGetIrp(Request)->UserBuffer;
+
+            if (pFeaturePkt == NULL)
+            {
+                status = STATUS_INVALID_DEVICE_REQUEST;
+            }
+            else
+            {
+                ULONG i;
+
+                status = STATUS_NOT_IMPLEMENTED;
+                for (i = 0; i < pContext->uNumOfClasses; i++)
+                {
+                    if (pContext->InputClasses[i]->GetFeatureFunc)
+                    {
+                        status = pContext->InputClasses[i]->GetFeatureFunc(pContext->InputClasses[i], pFeaturePkt);
+                        if (!NT_SUCCESS(status))
+                        {
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        break;
+
     default:
         TraceEvents(TRACE_LEVEL_INFORMATION, DBG_IOCTLS,
                     "Unrecognized IOCTL %d\n", IoControlCode);
@@ -225,6 +263,13 @@ ProcessInputEvent(
         // send report(s) up
         for (i = 0; i < pContext->uNumOfClasses; i++)
         {
+            // Ask each class if any collection needs before report
+            if (pContext->InputClasses[i]->EventToCollectFunc)
+            {
+                pContext->InputClasses[i]->EventToCollectFunc(
+                    pContext->InputClasses[i],
+                    pEvent);
+            }
             CompleteHIDQueueRequest(pContext, pContext->InputClasses[i]);
         }
     }
@@ -415,7 +460,7 @@ VIOInputBuildReportDescriptor(PINPUT_DEVICE pContext)
 {
     DYNAMIC_ARRAY ReportDescriptor = { NULL };
     NTSTATUS status = STATUS_SUCCESS;
-    VIRTIO_INPUT_CFG_DATA KeyData, RelData, AbsData, LedData;
+    VIRTIO_INPUT_CFG_DATA KeyData, RelData, AbsData, LedData, MscData;
     SIZE_T cbReportDescriptor;
     UCHAR i, uReportID = 0;
 
@@ -451,6 +496,16 @@ VIOInputBuildReportDescriptor(PINPUT_DEVICE pContext)
             &AbsData.u.bitmap[i], 1);
     }
 
+    // Misc config
+    MscData.size = SelectInputConfig(pContext, VIRTIO_INPUT_CFG_EV_BITS, EV_MSC);
+    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "Got EV_MSC bits size %d\n", MscData.size);
+    for (i = 0; i < MscData.size; i++)
+    {
+        VirtIOWdfDeviceGet(
+            &pContext->VDevice, offsetof(struct virtio_input_config, u.bitmap[i]),
+            &MscData.u.bitmap[i], 1);
+    }
+
     // if we have any relative axes, we'll expose a mouse device
     // if we have any absolute axes, we may expose a mouse as well
     if (!InputCfgDataEmpty(&RelData) || !InputCfgDataEmpty(&AbsData))
@@ -488,7 +543,8 @@ VIOInputBuildReportDescriptor(PINPUT_DEVICE pContext)
             pContext,
             &ReportDescriptor,
             &AbsData,
-            &KeyData);
+            &KeyData,
+            &MscData);
         if (!NT_SUCCESS(status))
         {
             goto Exit;
diff --git a/vioinput/sys/Hid.h b/vioinput/sys/Hid.h
index 2fcb4097..8147105b 100644
--- a/vioinput/sys/Hid.h
+++ b/vioinput/sys/Hid.h
@@ -78,7 +78,13 @@
 #ifndef HID_USAGE_DIGITIZER_STYLUS
 #define HID_USAGE_DIGITIZER_STYLUS             0x20
 #endif
+#ifndef HID_USAGE_DIGITIZER_FINGER
+#define HID_USAGE_DIGITIZER_FINGER             0x22
+#endif
 #define HID_USAGE_DIGITIZER_CONTACT_ID         0x51
+#define HID_USAGE_DIGITIZER_CONTACT_COUNT      0x54
+#define HID_USAGE_DIGITIZER_CONTACT_COUNT_MAX  0x55
+#define HID_USAGE_DIGITIZER_SCAN_TIME          0x56
 #define HID_USAGE_DIGITIZER_DATA_VALID_FINGER  0x37
 
 #ifndef HID_USAGE_SIMULATION_BRAKE
diff --git a/vioinput/sys/HidTablet.c b/vioinput/sys/HidTablet.c
index 6fbe5541..ba199d1a 100644
--- a/vioinput/sys/HidTablet.c
+++ b/vioinput/sys/HidTablet.c
@@ -38,34 +38,173 @@
 #include "HidTablet.tmh"
 #endif
 
+// Defined in drivers/hid/hid-multitouch.c
+#define MT_DEFAULT_MAXCONTACT   10
+#define MT_MAX_MAXCONTACT       250
+#define MT_DIRTY_GROUPS ((MT_MAX_MAXCONTACT + MT_MAX_MAXCONTACT%MT_MAX_MAXCONTACT)/(sizeof(ULONG)*8))
+
+#pragma pack(push,1)
+typedef struct _tagInputClassTabletFeatureMaxContact
+{
+    UCHAR uReportID;
+    UCHAR uMaxContacts;
+}INPUT_CLASS_TABLET_FEATURE_MAX_CONTACT, *PINPUT_CLASS_TABLET_FEATURE_MAX_CONTACT;
+
+typedef struct _tagInputClassTabletSlot
+{
+    UCHAR uFlags;
+    USHORT uContactID;
+    USHORT uAxisX;
+    USHORT uAxisY;
+} INPUT_CLASS_TABLET_SLOT, *PINPUT_CLASS_TABLET_SLOT;
+#pragma pack(pop)
+
+typedef struct _tagInputClassTabletTrackingID
+{
+    LONG uID;
+    BOOLEAN bPendingDel;
+} INPUT_CLASS_TABLET_TRACKING_ID, * PINPUT_CLASS_TABLET_TRACKING_ID;
+
 typedef struct _tagInputClassTablet
 {
     INPUT_CLASS_COMMON Common;
+    BOOLEAN bMT;
+    BOOLEAN bIdentifiableMT;
+    BOOLEAN bMscTs;
+    ULONG uMaxContacts;
+    ULONG uLastMTSlot;
+    PINPUT_CLASS_TABLET_SLOT pContactStat;
+    PINPUT_CLASS_TABLET_TRACKING_ID pTrackingID;
+
+    /*
+     * HID Tablet report layout:
+     * Total size in bytes: 1 + 7 * numContacts + 1 + 4
+     * +---------------+-+-+-+-+-+---------------+----------+------------+
+     * | Byte Offset   |7|6|5|4|3|     2         |    1     |     0      |
+     * +---------------+-+-+-+-+-+---------------+----------+------------+
+     * | 0             |                    Report ID                    |
+     * | i*7+1         |   Pad   | Barrel Switch | In-range | Tip Switch |
+     * | i*7+[2,3]     |                    Contact ID                   |
+     * | i*7+[4,5]     |                      x-axis                     |
+     * | i*7+[6,7]     |                      y-axis                     |
+     * | (i+1)*7+[1,7] |                   Contact i+1                   |
+     * | (i+2)*7+[1,7] |                   Contact i+2                   |
+     * | ...           |                                                 |
+     * | (n-1)*7+[1,7] |                   Contact n-1                   |
+     * | n*7+1         |                  Contact Count                  |
+     * | n*7+[2,5]     |                    Scan Time                    |
+     * +---------------+-+-+-+-+-+------------+----------+---------------+
+     */
+} INPUT_CLASS_TABLET, *PINPUT_CLASS_TABLET;
 
-    // the tablet HID report is laid out as follows:
-    // offset 0
-    // * report ID
-    // offset 1
-    // * switches and flags
-    // ** bit 0 tip switch
-    // ** bit 1 in range
-    // ** bit 2 barrel switch
-    // ** bits 3-7 padding
-    // offset 2
-    // * X axis, 2 bytes, absolute
-    // offset 4
-    // * Y axis, 2 bytes, absolute
+static NTSTATUS
+HIDTabletGetFeature(
+    PINPUT_CLASS_COMMON pClass,
+    PHID_XFER_PACKET pFeaturePkt)
+{
+    PINPUT_CLASS_TABLET pTabletDesc = (PINPUT_CLASS_TABLET)pClass;
+    UCHAR uReportID = *(PUCHAR)pFeaturePkt->reportBuffer;
+    NTSTATUS status = STATUS_SUCCESS;
 
-} INPUT_CLASS_TABLET, *PINPUT_CLASS_TABLET;
+    TraceEvents(TRACE_LEVEL_VERBOSE, DBG_READ, "--> %s\n", __FUNCTION__);
+
+    switch (uReportID)
+    {
+    case REPORTID_FEATURE_TABLET_MAX_COUNT:
+        if (pFeaturePkt->reportBufferLen >= sizeof(INPUT_CLASS_TABLET_FEATURE_MAX_CONTACT))
+        {
+            PINPUT_CLASS_TABLET_FEATURE_MAX_CONTACT pFtrReport = (PINPUT_CLASS_TABLET_FEATURE_MAX_CONTACT)pFeaturePkt->reportBuffer;
+
+            pFtrReport->uMaxContacts = (UCHAR)pTabletDesc->uMaxContacts;
+        }
+        else
+        {
+            status = STATUS_BUFFER_TOO_SMALL;
+        }
+        break;
+    default:
+        status = STATUS_INVALID_PARAMETER;
+        break;
+    }
+
+    TraceEvents(TRACE_LEVEL_VERBOSE, DBG_READ, "<-- %s\n", __FUNCTION__);
+
+    return status;
+}
+
+static NTSTATUS
+HIDTabletEventToCollect(
+    PINPUT_CLASS_COMMON pClass,
+    PVIRTIO_INPUT_EVENT pEvent)
+{
+    PINPUT_CLASS_TABLET pTabletDesc = (PINPUT_CLASS_TABLET)pClass;
+    PUCHAR pReport = pClass->pHidReport;
+    PINPUT_CLASS_TABLET_SLOT pReportSlot;
+    ULONG uNumContacts;
+
+    TraceEvents(TRACE_LEVEL_VERBOSE, DBG_READ, "--> %s\n", __FUNCTION__);
+
+    switch (pEvent->type)
+    {
+    case EV_SYN:
+        switch (pEvent->code)
+        {
+        case SYN_REPORT:
+            /*
+             * For identifiable MT, bDirty isn't set when handling MT events but
+             *   only states are saved. First touching contact may lift first
+             *   thus the first valid contact may not always 1st in pContactStat.
+             *   So check and find the actual contacts to report, copy to final
+             *   report buffer and set bDirty.
+             * Anonymous MT already sets bDirty when seeing SYN_MT_REPORT.
+             */
+            if (pTabletDesc->bIdentifiableMT)
+            {
+                UCHAR uContacts = 0;
+
+                pReport[HID_REPORT_DATA_OFFSET + sizeof(INPUT_CLASS_TABLET_SLOT) * pTabletDesc->uMaxContacts] = uContacts;
+                for (uNumContacts = 0; uNumContacts < pTabletDesc->uMaxContacts; uNumContacts++)
+                {
+                    if (pTabletDesc->pTrackingID[uNumContacts].uID != -1)
+                    {
+                        RtlCopyMemory(
+                            &((PINPUT_CLASS_TABLET_SLOT)&pReport[HID_REPORT_DATA_OFFSET])[uContacts++],
+                            &pTabletDesc->pContactStat[uNumContacts],
+                            sizeof(INPUT_CLASS_TABLET_SLOT));
+                    }
+                }
+
+                if (uContacts)
+                {
+                    pReport[HID_REPORT_DATA_OFFSET + sizeof(INPUT_CLASS_TABLET_SLOT) * pTabletDesc->uMaxContacts] = uContacts;
+                    pClass->bDirty = TRUE;
+                }
+            }
+            break;
+        default:
+            break;
+        }
+        break;
+    default:
+        break;
+    }
+
+    TraceEvents(TRACE_LEVEL_VERBOSE, DBG_READ, "<-- %s\n", __FUNCTION__);
+
+    return STATUS_SUCCESS;
+}
 
 static NTSTATUS
 HIDTabletEventToReport(
     PINPUT_CLASS_COMMON pClass,
     PVIRTIO_INPUT_EVENT pEvent)
 {
+    PINPUT_CLASS_TABLET pTabletDesc = (PINPUT_CLASS_TABLET)pClass;
     PUCHAR pReport = pClass->pHidReport;
     PUSHORT pAxisReport;
+    PINPUT_CLASS_TABLET_SLOT pReportSlot;
     UCHAR uBits;
+    ULONG uNumContacts;
 
     TraceEvents(TRACE_LEVEL_VERBOSE, DBG_READ, "--> %s\n", __FUNCTION__);
 
@@ -73,22 +212,94 @@ HIDTabletEventToReport(
     switch (pEvent->type)
     {
     case EV_ABS:
-        switch (pEvent->code)
+        if (pTabletDesc->bMT)
         {
-        case ABS_X:
-            pAxisReport = (USHORT *)&pReport[HID_REPORT_DATA_OFFSET + 1];
-            break;
-        case ABS_Y:
-            pAxisReport = (USHORT *)&pReport[HID_REPORT_DATA_OFFSET + 3];
-            break;
-        default:
-            pAxisReport = NULL;
-            break;
+            /*
+             * For identifiable MT, contact event are firstly saved into
+             *   pContactStat then copied to report buffer by valid tracking ID.
+             * For anonymous MT, contact event are directly saved into report
+             *   buffer one by one on seeing SYN_MT_REPORT.
+             */
+            if (pTabletDesc->bIdentifiableMT)
+            {
+                pReportSlot = &pTabletDesc->pContactStat[pTabletDesc->uLastMTSlot];
+            } else
+            {
+                pReportSlot = &((PINPUT_CLASS_TABLET_SLOT)&pReport[HID_REPORT_DATA_OFFSET])[pTabletDesc->uLastMTSlot];
+            }
+            switch (pEvent->code)
+            {
+            case ABS_MT_SLOT:
+                /*
+                 * Subsequent identifiable MT event will re-use last set MT_SLOT
+                 *   until new slot arrives so we need save it for later usage
+                 *   and keep using uLastMTSlot as current slot for other operation.
+                 * Only identifiable MT will send MT_SLOT. Still add protection
+                 *   in case back-end somehow goes wrong.
+                 */
+                if (pTabletDesc->bIdentifiableMT)
+                {
+                    if (pEvent->value < pTabletDesc->uMaxContacts)
+                    {
+                        pTabletDesc->uLastMTSlot = (ULONG)pEvent->value;
+                    }
+                    else
+                    {
+                        pTabletDesc->uLastMTSlot = 0;
+                    }
+                }
+                break;
+            case ABS_MT_POSITION_X:
+                pReportSlot->uAxisX = (USHORT)pEvent->value;
+                break;
+            case ABS_MT_POSITION_Y:
+                pReportSlot->uAxisY = (USHORT)pEvent->value;
+                break;
+            case ABS_MT_TRACKING_ID:
+                /*
+                 * Check if negative tracking ID for actual contact up & down.
+                 * Contact ID is bind to slot until changed, save it to operate
+                 * subsequent MT event. In case of negative tracking ID, don't
+                 * mark as unused slot with -1 but mark as pending only so that
+                 * the contact can be reported lift up on EN_SYN and unset then.
+                 */
+                if ((LONG)pEvent->value < 0)
+                {
+                    pTabletDesc->pTrackingID[pTabletDesc->uLastMTSlot].bPendingDel = TRUE;
+                    pReportSlot->uFlags &= ~0x01;
+                }
+                else
+                {
+                    pTabletDesc->pTrackingID[pTabletDesc->uLastMTSlot].uID = (LONG)pEvent->value;
+                    pReportSlot->uContactID = (USHORT)pEvent->value;
+                    pReportSlot->uFlags |= 0x01;
+                }
+                break;
+            default:
+                break;
+            }
         }
-        if (pAxisReport != NULL)
+        // ST
+        else
         {
-            *pAxisReport = (USHORT)pEvent->value;
-            pClass->bDirty = TRUE;
+            /*
+             * ST always fills ABS_X/ABS_Y and EV_KEY in 1st slot while
+             * uLastMTSlot remains unchanged for all events.
+             */
+            pReportSlot = &((PINPUT_CLASS_TABLET_SLOT)&pReport[HID_REPORT_DATA_OFFSET])[pTabletDesc->uLastMTSlot];
+            switch (pEvent->code)
+            {
+            case ABS_X:
+                pReportSlot->uAxisX = (USHORT)pEvent->value;
+                pClass->bDirty = TRUE;
+                break;
+            case ABS_Y:
+                pReportSlot->uAxisY = (USHORT)pEvent->value;
+                pClass->bDirty = TRUE;
+                break;
+            default:
+                break;
+            }
         }
         break;
     case EV_KEY:
@@ -108,39 +319,152 @@ HIDTabletEventToReport(
             uBits = 0x00;
             break;
         }
+
+        // MT will set bDirty before reporting at EV_SYN so drop all bits here.
+        if (pTabletDesc->bMT)
+        {
+            uBits = 0x00;
+        }
+
         if (uBits)
         {
+            pReportSlot = &((PINPUT_CLASS_TABLET_SLOT)&pReport[HID_REPORT_DATA_OFFSET])[pTabletDesc->uLastMTSlot];
             if (pEvent->value)
             {
-                pReport[HID_REPORT_DATA_OFFSET] |= uBits;
+                pReportSlot->uFlags |= uBits;
             }
             else
             {
-                pReport[HID_REPORT_DATA_OFFSET] &= ~uBits;
+                pReportSlot->uFlags &= ~uBits;
             }
             pClass->bDirty = TRUE;
         }
         break;
+    case EV_MSC:
+        switch (pEvent->code)
+        {
+        case MSC_TIMESTAMP:
+            if (pTabletDesc->bMscTs)
+            {
+                PLONG pScanTime = (PLONG)&pReport[HID_REPORT_DATA_OFFSET + sizeof(INPUT_CLASS_TABLET_SLOT) * pTabletDesc->uMaxContacts + 1];
+                // Convert MSC_TIMESTAMP microseconds to 100 microseconds
+                *pScanTime = ((ULONG)pEvent->value / 100);
+            }
+            break;
+        default:
+            break;
+        }
+        break;
+    case EV_SYN:
+        switch (pEvent->code)
+        {
+        case SYN_REPORT:
+            /*
+             * Post-processing SYN_REPORT after done reporting.
+             * For ST, the num of contacts to report is always 1 so nothing to do.
+             * For MT, clear the number of contacts to report so that up-to-date
+             *   number can be re-count before reporting on next EV_SYN.
+             *   For identifiable MT, clear pending tracking ID.
+             *   For anonymous MT, clear uLastMTSlot which is increased on
+             *     SYN_MT_REPORT.
+             */
+            if (pTabletDesc->bIdentifiableMT)
+            {
+                for (uNumContacts = 0; uNumContacts < pTabletDesc->uMaxContacts; uNumContacts++)
+                {
+                    if (pTabletDesc->pTrackingID[uNumContacts].bPendingDel)
+                    {
+                        pTabletDesc->pTrackingID[uNumContacts].uID = -1;
+                        pTabletDesc->pTrackingID[uNumContacts].bPendingDel = FALSE;
+                    }
+                }
+                pReport[HID_REPORT_DATA_OFFSET + sizeof(INPUT_CLASS_TABLET_SLOT) * pTabletDesc->uMaxContacts] = 0;
+            }
+            else if (pTabletDesc->bMT)
+            {
+                pTabletDesc->uLastMTSlot = 0;
+                pReport[HID_REPORT_DATA_OFFSET + sizeof(INPUT_CLASS_TABLET_SLOT) * pTabletDesc->uMaxContacts] = 0;
+            }
+            break;
+        case SYN_MT_REPORT:
+            /*
+             * Anonymous MT won't use MT_SLOT/MT_TRACKING_ID for each contacts,
+             * so move to next slot when seeing SYN_MT_REPORT. If case of
+             * overflow, round uLastMTSlot the 1st but keep number of contacts.
+             */
+            if (pTabletDesc->bMT && !pTabletDesc->bIdentifiableMT)
+            {
+                ++pTabletDesc->uLastMTSlot;
+                if (pTabletDesc->uLastMTSlot <= pTabletDesc->uMaxContacts)
+                {
+                    ++pReport[HID_REPORT_DATA_OFFSET + sizeof(INPUT_CLASS_TABLET_SLOT) * pTabletDesc->uMaxContacts];
+                }
+                if (++pTabletDesc->uLastMTSlot >= pTabletDesc->uMaxContacts)
+                {
+                    pTabletDesc->uLastMTSlot = 0;
+                }
+                pClass->bDirty = TRUE;
+            }
+            break;
+        default:
+            break;
+        }
+        break;
     }
 
     TraceEvents(TRACE_LEVEL_VERBOSE, DBG_READ, "<-- %s\n", __FUNCTION__);
+
     return STATUS_SUCCESS;
 }
 
+static VOID
+HIDTabletCleanup(
+    PINPUT_CLASS_COMMON pClass)
+{
+    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "--> %s\n", __FUNCTION__);
+
+    PINPUT_CLASS_TABLET pTabletDesc = (PINPUT_CLASS_TABLET)pClass;
+
+    if (pTabletDesc->pContactStat)
+    {
+        VIOInputFree(&pTabletDesc->pContactStat);
+    }
+    if (pTabletDesc->pTrackingID)
+    {
+        VIOInputFree(&pTabletDesc->pTrackingID);
+    }
+
+    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "<-- %s\n", __FUNCTION__);
+}
+
 NTSTATUS
 HIDTabletProbe(
     PINPUT_DEVICE pContext,
     PDYNAMIC_ARRAY pHidDesc,
     PVIRTIO_INPUT_CFG_DATA pAxes,
-    PVIRTIO_INPUT_CFG_DATA pButtons)
+    PVIRTIO_INPUT_CFG_DATA pButtons,
+    PVIRTIO_INPUT_CFG_DATA pMisc)
 {
     PINPUT_CLASS_TABLET pTabletDesc = NULL;
     NTSTATUS status = STATUS_SUCCESS;
     UCHAR i, uValue;
-    ULONG uAxisCode, uNumOfAbsAxes = 0;
+    ULONG uAxisCode, uNumOfAbsAxes = 0, uNumOfMTAbsAxes = 0, uNumContacts = 0;
 
     TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "--> %s\n", __FUNCTION__);
 
+    // allocate and initialize pTabletDesc
+    pTabletDesc = VIOInputAlloc(sizeof(INPUT_CLASS_TABLET));
+    if (pTabletDesc == NULL)
+    {
+        status = STATUS_INSUFFICIENT_RESOURCES;
+        goto Exit;
+    }
+
+    // Init as single touch
+    pTabletDesc->bMT = FALSE;
+    pTabletDesc->bIdentifiableMT = FALSE;
+    pTabletDesc->uMaxContacts = 1;
+
     // we expect to see two absolute axes, X and Y
     for (i = 0; i < pAxes->size; i++)
     {
@@ -152,7 +476,33 @@ HIDTabletProbe(
             {
                 uNumOfAbsAxes++;
             }
-            else
+            else if (uAxisCode == ABS_MT_SLOT)
+            {
+                struct virtio_input_absinfo AbsInfo;
+                GetAbsAxisInfo(pContext, uAxisCode, &AbsInfo);
+
+                pTabletDesc->uMaxContacts = AbsInfo.max + 1;
+                if (pTabletDesc->uMaxContacts > MT_MAX_MAXCONTACT)
+                {
+                    pTabletDesc->uMaxContacts = MT_MAX_MAXCONTACT;
+                    TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "Back end report more contacts (%d) than front end can support (%d). Limit to (%d)\n",
+                        AbsInfo.max + 1, MT_MAX_MAXCONTACT, MT_MAX_MAXCONTACT);
+                }
+                pTabletDesc->bMT = TRUE;
+                pTabletDesc->bIdentifiableMT = TRUE;
+            }
+            else if ((uAxisCode >= ABS_MT_TOUCH_MAJOR) && (uAxisCode <= ABS_MT_TOOL_Y))
+            {
+                pTabletDesc->bMT = TRUE;
+                if (uAxisCode == ABS_MT_POSITION_X || uAxisCode == ABS_MT_POSITION_Y)
+                {
+                    uNumOfMTAbsAxes++;
+                }
+                if (uAxisCode == ABS_MT_TRACKING_ID)
+                {
+                    pTabletDesc->bIdentifiableMT = TRUE;
+                }
+            } else
             {
                 uNonAxes |= (1 << uValue);
             }
@@ -163,9 +513,84 @@ HIDTabletProbe(
     if (uNumOfAbsAxes != 2)
     {
         TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "Tablet axes not found\n");
+        status = STATUS_INSUFFICIENT_RESOURCES;
+        goto Exit;
+    }
+
+    pTabletDesc->bMscTs = FALSE;
+    for (i = 0; i < pMisc->size; i++)
+    {
+        while (DecodeNextBit(&pMisc->u.bitmap[i], &uValue))
+        {
+            UCHAR msc_event = uValue + 8 * i;
+            if (msc_event == MSC_TIMESTAMP)
+            {
+                pTabletDesc->bMscTs = TRUE;
+            }
+        }
+    }
+
+    /*
+     * MT could be type A (anonymous contacts) or type B (identifiable contacts)
+     * For anonymous MT, seeing another SYN_MT_REPORT indicates a new contact
+     *   in same report.
+     * For identifiable MT, ABS_MT_SLOT and ABS_MT_TRACKING_ID are used to
+     *   identify the contact number and identity.
+     * If we got type A, uMaxContacts can't be parsed from ABS_MT_SLOT thus
+     *   limit to MT_DEFAULT_MAXCONTACT.
+     */
+    if (!pTabletDesc->bIdentifiableMT && pTabletDesc->bMT)
+    {
+        pTabletDesc->uMaxContacts = MT_DEFAULT_MAXCONTACT;
+        TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "Type A (identifiable contacts) MT maximum contacts is limited to (%d). Consider to increase MT_DEFAULT_MAXCONTACT if necessary.\n",
+            MT_DEFAULT_MAXCONTACT);
+    }
+
+    if (pTabletDesc->bMT && uNumOfMTAbsAxes != 2)
+    {
+        pTabletDesc->bMT = FALSE;
+        pTabletDesc->bIdentifiableMT = FALSE;
+        pTabletDesc->uMaxContacts = 1;
+        TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "Got MT abs info but doesn't have ABS_MT_POSITION_X and ABS_MT_POSITION_Y, fall back to ST\n");
+    }
+
+    if (pTabletDesc->uMaxContacts > MT_MAX_MAXCONTACT)
+    {
+        TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "Backend report more maximum contacts (%d) than frontend can support (%d), limit to (%d). Consider to increase MT_MAX_MAXCONTACT if necessary.\n",
+            pTabletDesc->uMaxContacts, MT_MAX_MAXCONTACT, MT_MAX_MAXCONTACT);
+        pTabletDesc->uMaxContacts = MT_MAX_MAXCONTACT;
+    }
+
+    // Simulate as ST for test
+    //pTabletDesc->bMT = FALSE;
+    //pTabletDesc->bIdentifiableMT = FALSE;
+    //pTabletDesc->uMaxContacts = 1;
+
+    // Allocate and all contact status for MT
+    if (pTabletDesc->bMT)
+    {
+        pTabletDesc->pContactStat = VIOInputAlloc(sizeof(INPUT_CLASS_TABLET_SLOT) * pTabletDesc->uMaxContacts);
+        if (pTabletDesc->pContactStat == NULL)
+        {
+            status = STATUS_INSUFFICIENT_RESOURCES;
+            goto Exit;
+        }
+    }
+
+    pTabletDesc->pTrackingID = VIOInputAlloc(sizeof(INPUT_CLASS_TABLET_TRACKING_ID) * pTabletDesc->uMaxContacts);
+    if (pTabletDesc->pTrackingID == NULL)
+    {
+        status = STATUS_INSUFFICIENT_RESOURCES;
         goto Exit;
     }
 
+    pTabletDesc->uLastMTSlot = 0;
+    for (uNumContacts = 0; uNumContacts < pTabletDesc->uMaxContacts; uNumContacts++)
+    {
+        pTabletDesc->pTrackingID[uNumContacts].uID = -1;
+        pTabletDesc->pTrackingID[uNumContacts].bPendingDel = FALSE;
+    }
+
     // claim our buttons from the pAxes bitmap
     for (i = 0; i < pButtons->size; i++)
     {
@@ -188,90 +613,171 @@ HIDTabletProbe(
         pAxes->u.bitmap[i] = uNonButtons;
     }
 
-    // allocate and initialize pTabletDesc
-    pTabletDesc = VIOInputAlloc(sizeof(INPUT_CLASS_TABLET));
-    if (pTabletDesc == NULL)
-    {
-        status = STATUS_INSUFFICIENT_RESOURCES;
-        goto Exit;
-    }
+    pTabletDesc->Common.GetFeatureFunc = HIDTabletGetFeature;
+    pTabletDesc->Common.EventToCollectFunc = HIDTabletEventToCollect;
     pTabletDesc->Common.EventToReportFunc = HIDTabletEventToReport;
+    pTabletDesc->Common.CleanupFunc = HIDTabletCleanup;
     pTabletDesc->Common.uReportID = (UCHAR)(pContext->uNumOfClasses + 1);
 
     HIDAppend2(pHidDesc, HID_TAG_USAGE_PAGE, HID_USAGE_PAGE_DIGITIZER);
-    HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER);
-    HIDAppend2(pHidDesc, HID_TAG_COLLECTION, HID_COLLECTION_APPLICATION);
-    HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_STYLUS);
-    HIDAppend2(pHidDesc, HID_TAG_COLLECTION, HID_COLLECTION_PHYSICAL);
+    HIDAppend2(pHidDesc, HID_TAG_USAGE, pTabletDesc->bMT ? HID_USAGE_TOUCH_SCREEN : HID_USAGE_DIGITIZER);
 
+    HIDAppend2(pHidDesc, HID_TAG_COLLECTION, HID_COLLECTION_APPLICATION);
     HIDAppend2(pHidDesc, HID_TAG_REPORT_ID, pTabletDesc->Common.uReportID);
+    HIDAppend2(pHidDesc, HID_TAG_USAGE, pTabletDesc->bMT ? HID_USAGE_DIGITIZER_FINGER : HID_USAGE_DIGITIZER_STYLUS);
 
-    // tip switch, one bit
-    HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_TIP_SWITCH);
-    HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MINIMUM, 0x00);
-    HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MAXIMUM, 0x01);
-    HIDAppend2(pHidDesc, HID_TAG_REPORT_SIZE, 0x01);
-    HIDAppend2(pHidDesc, HID_TAG_REPORT_COUNT, 0x01);
-    HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE);
+    for (uNumContacts = 0; uNumContacts < pTabletDesc->uMaxContacts; uNumContacts++)
+    {
+        // Collection Logical for all contacts for reporting in hybrid mode
+        HIDAppend2(pHidDesc, HID_TAG_COLLECTION, HID_COLLECTION_LOGICAL);
 
-    // in range flag, one bit
-    HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_IN_RANGE);
-    HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE);
+        // Change to digitizer page for touch
+        HIDAppend2(pHidDesc, HID_TAG_USAGE_PAGE, HID_USAGE_PAGE_DIGITIZER);
 
-    // barrel switch, one bit
-    HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_BARREL_SWITCH);
-    HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE);
-
-    // padding
-    HIDAppend2(pHidDesc, HID_TAG_REPORT_COUNT, 0x05);
-    HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE | HID_DATA_FLAG_CONSTANT);
+        // Same logical minimum and maximum applied to below flags, 1 bit each, 1 byte total
+        HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MINIMUM, 0x00);
+        HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MAXIMUM, 0x01);
+        HIDAppend2(pHidDesc, HID_TAG_REPORT_SIZE, 0x01);
+        HIDAppend2(pHidDesc, HID_TAG_REPORT_COUNT, 0x01);
 
-    HIDAppend2(pHidDesc, HID_TAG_USAGE_PAGE, HID_USAGE_PAGE_GENERIC);
-    HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_GENERIC_POINTER);
+        // tip switch, one bit
+        HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_TIP_SWITCH);
+        HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE);
 
-    HIDAppend2(pHidDesc, HID_TAG_COLLECTION, HID_COLLECTION_PHYSICAL);
-    for (uAxisCode = ABS_X; uAxisCode <= ABS_Y; uAxisCode++)
-    {
-        struct virtio_input_absinfo AbsInfo;
-        GetAbsAxisInfo(pContext, uAxisCode, &AbsInfo);
+        if (!pTabletDesc->bMT)
+        {
+            // in range flag, one bit
+            HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_IN_RANGE);
+            HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE);
 
-        TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "Got abs axis %d, min %d, max %d\n",
-                    uAxisCode, AbsInfo.min, AbsInfo.max);
+            // barrel switch, one bit
+            HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_BARREL_SWITCH);
+            HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE);
+        }
 
-        HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MINIMUM, AbsInfo.min);
-        HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MAXIMUM, AbsInfo.max);
+        // padding
+        HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MAXIMUM, 0x00);
+        HIDAppend2(pHidDesc, HID_TAG_REPORT_COUNT, pTabletDesc->bMT ? 0x07 : 0x05);
+        HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE | HID_DATA_FLAG_CONSTANT);
 
+        // Contact Identifier, 2 bytes
         HIDAppend2(pHidDesc, HID_TAG_REPORT_SIZE, 0x10);
         HIDAppend2(pHidDesc, HID_TAG_REPORT_COUNT, 0x01);
-        HIDAppend2(pHidDesc, HID_TAG_UNIT_EXPONENT, 0x0D); // -3
+        HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_CONTACT_ID);
+        HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MAXIMUM, pTabletDesc->uMaxContacts - 1);
+        HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE);
+
+        // Change to generic desktop page for coordinates
+        HIDAppend2(pHidDesc, HID_TAG_USAGE_PAGE, HID_USAGE_PAGE_GENERIC);
+        HIDAppend2(pHidDesc, HID_TAG_UNIT_EXPONENT, 0x0D); // 10^(-3)
         HIDAppend2(pHidDesc, HID_TAG_UNIT, 0x00);          // none
 
-        HIDAppend2(pHidDesc, HID_TAG_USAGE,
-                   (uAxisCode == ABS_X ? HID_USAGE_GENERIC_X : HID_USAGE_GENERIC_Y));
+        // 2 bytes each axis
+        for (uAxisCode = ABS_X; uAxisCode <= ABS_Y; uAxisCode++)
+        {
+            struct virtio_input_absinfo AbsInfo;
+            GetAbsAxisInfo(pContext, uAxisCode, &AbsInfo);
+
+            TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "Got abs axis %d, min %d, max %d\n",
+                uAxisCode, AbsInfo.min, AbsInfo.max);
+
+            // logical == physical, no offset and scale
+            // Device Class Definition for HID 1.11, 6.2.2.7
+            // Resolution = (Logical Maximum - Logical Minimum) /
+            //    ((Physical Maximum - Physical Minimum) * (10 Unit Exponent))
+            HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MINIMUM, AbsInfo.min);
+            HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MAXIMUM, AbsInfo.max);
+            HIDAppend2(pHidDesc, HID_TAG_PHYSICAL_MINIMUM, AbsInfo.min);
+            HIDAppend2(pHidDesc, HID_TAG_PHYSICAL_MAXIMUM, AbsInfo.max);
+
+            HIDAppend2(pHidDesc, HID_TAG_USAGE,
+                (uAxisCode == ABS_X ? HID_USAGE_GENERIC_X : HID_USAGE_GENERIC_Y));
+
+            HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE);
+        }
+
+        HIDAppend1(pHidDesc, HID_TAG_END_COLLECTION); //HID_COLLECTION_LOGICAL
+    }
+
+    // Change to digitizer page for contacts information
+    HIDAppend2(pHidDesc, HID_TAG_USAGE_PAGE, HID_USAGE_PAGE_DIGITIZER);
+
+    // Same range for both number of contacts in current report and maximum number of supported contacts, 1 byte each
+    HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MINIMUM, 0x00);
+    HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MAXIMUM, pTabletDesc->uMaxContacts);
+    HIDAppend2(pHidDesc, HID_TAG_REPORT_SIZE, 0x08);
+    HIDAppend2(pHidDesc, HID_TAG_REPORT_COUNT, 0x01);
+
+    HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_CONTACT_COUNT);
+    HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE);
 
-        HIDAppend2(pHidDesc, HID_TAG_PHYSICAL_MINIMUM, AbsInfo.min);
-        HIDAppend2(pHidDesc, HID_TAG_PHYSICAL_MAXIMUM, AbsInfo.max);
+    if (pTabletDesc->bMscTs)
+    {
+        HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_SCAN_TIME);
+        HIDAppend2(pHidDesc, HID_TAG_UNIT_EXPONENT, 0x0A); // 10^(-4), 100 us
+        HIDAppend2(pHidDesc, HID_TAG_UNIT, 0x01); // Time system in unit of s
+        HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MAXIMUM, LONG_MAX);
+        HIDAppend2(pHidDesc, HID_TAG_REPORT_SIZE, 0x20);
+        HIDAppend2(pHidDesc, HID_TAG_REPORT_COUNT, 0x01);
         HIDAppend2(pHidDesc, HID_TAG_INPUT, HID_DATA_FLAG_VARIABLE);
+
+        // Restore for subsequent item
+        HIDAppend2(pHidDesc, HID_TAG_UNIT_EXPONENT, 0x00);
+        HIDAppend2(pHidDesc, HID_TAG_UNIT, 0x00);
+        HIDAppend2(pHidDesc, HID_TAG_LOGICAL_MAXIMUM, pTabletDesc->uMaxContacts);
+        HIDAppend2(pHidDesc, HID_TAG_REPORT_SIZE, 0x08);
+        HIDAppend2(pHidDesc, HID_TAG_REPORT_COUNT, 0x01);
     }
-    HIDAppend1(pHidDesc, HID_TAG_END_COLLECTION);
 
-    HIDAppend1(pHidDesc, HID_TAG_END_COLLECTION);
-    HIDAppend1(pHidDesc, HID_TAG_END_COLLECTION);
+    // IOCTL_HID_GET_FEATURE will query the report for maximum count
+    HIDAppend2(pHidDesc, HID_TAG_REPORT_ID, REPORTID_FEATURE_TABLET_MAX_COUNT);
+    HIDAppend2(pHidDesc, HID_TAG_USAGE, HID_USAGE_DIGITIZER_CONTACT_COUNT_MAX);
+    HIDAppend2(pHidDesc, HID_TAG_FEATURE, HID_DATA_FLAG_VARIABLE | HID_DATA_FLAG_CONSTANT);
+
+    HIDAppend1(pHidDesc, HID_TAG_END_COLLECTION); //HID_COLLECTION_APPLICATION
 
     TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "Created HID tablet report descriptor\n");
 
     // calculate the tablet HID report size
     pTabletDesc->Common.cbHidReportSize =
         1 + // report ID
-        1 + // flags
-        uNumOfAbsAxes * 2; // axes
+        sizeof(INPUT_CLASS_TABLET_SLOT) * pTabletDesc->uMaxContacts + // max contacts * per-contact packet. See INPUT_CLASS_TABLET_SLOT and INPUT_CLASS_TABLET for layout details.
+        1 + // Actual contact count
+        (pTabletDesc->bMscTs ? sizeof(LONG) : 0) // Scan time
+        ;
 
     // register the tablet class
     status = RegisterClass(pContext, &pTabletDesc->Common);
+    if (NT_SUCCESS(status))
+    {
+        PUCHAR pReport = pTabletDesc->Common.pHidReport;
+
+        /*
+         * For ST, the number of contacts to report is always 1.
+         * For MT, the number of contacts to report is counted at SYN_REPORT.
+         */
+        if (pTabletDesc->bMT)
+        {
+            pReport[HID_REPORT_DATA_OFFSET + sizeof(INPUT_CLASS_TABLET_SLOT) * pTabletDesc->uMaxContacts] = 0;
+        }
+        else
+        {
+            pReport[HID_REPORT_DATA_OFFSET + sizeof(INPUT_CLASS_TABLET_SLOT) * pTabletDesc->uMaxContacts] = 1;
+        }
+    }
+
 
 Exit:
-    if (!NT_SUCCESS(status) && pTabletDesc != NULL)
+    if (!NT_SUCCESS(status) && pTabletDesc)
     {
+        if (pTabletDesc->pContactStat)
+        {
+            VIOInputFree(&pTabletDesc->pContactStat);
+        }
+        if (pTabletDesc->pTrackingID)
+        {
+            VIOInputFree(&pTabletDesc->pTrackingID);
+        }
         VIOInputFree(&pTabletDesc);
     }
 
diff --git a/vioinput/sys/vioinput.h b/vioinput/sys/vioinput.h
index 50c7b078..6c51a281 100644
--- a/vioinput/sys/vioinput.h
+++ b/vioinput/sys/vioinput.h
@@ -83,6 +83,8 @@ typedef struct _tagInputClassCommon
     // the HID report is dirty and should be sent up
     BOOLEAN bDirty;
 
+    NTSTATUS(*GetFeatureFunc)(struct _tagInputClassCommon *pClass, PHID_XFER_PACKET pFeaturePkt);
+    NTSTATUS(*EventToCollectFunc)(struct _tagInputClassCommon* pClass, PVIRTIO_INPUT_EVENT pEvent);
     NTSTATUS(*EventToReportFunc)(struct _tagInputClassCommon *pClass, PVIRTIO_INPUT_EVENT pEvent);
     NTSTATUS(*ReportToEventFunc)(struct _tagInputClassCommon *pClass, struct _tagInputDevice *pContext,
                                  WDFREQUEST Request, PUCHAR pReport, ULONG cbReport);
@@ -91,6 +93,7 @@ typedef struct _tagInputClassCommon
 } INPUT_CLASS_COMMON, *PINPUT_CLASS_COMMON;
 
 #define MAX_INPUT_CLASS_COUNT 5
+#define REPORTID_FEATURE_TABLET_MAX_COUNT (MAX_INPUT_CLASS_COUNT+1)
 
 typedef struct _tagInputDevice
 {
@@ -194,6 +197,7 @@ typedef struct virtio_input_event_with_request
 #define EV_KEY        0x01
 #define EV_REL        0x02
 #define EV_ABS        0x03
+#define EV_MSC        0x04
 #define EV_LED        0x11
 
 // Button codes
@@ -247,6 +251,30 @@ typedef struct virtio_input_event_with_request
 #define ABS_TILT_Y    0x1b
 #define ABS_MISC      0x28
 
+// ABS_MT event codes defined in include/uapi/linux/input-event-codes.h
+#define ABS_MT_SLOT         0x2f    /* MT slot being modified */
+#define ABS_MT_TOUCH_MAJOR  0x30    /* Major axis of touching ellipse */
+#define ABS_MT_TOUCH_MINOR  0x31    /* Minor axis (omit if circular) */
+#define ABS_MT_WIDTH_MAJOR  0x32    /* Major axis of approaching ellipse */
+#define ABS_MT_WIDTH_MINOR  0x33    /* Minor axis (omit if circular) */
+#define ABS_MT_ORIENTATION  0x34    /* Ellipse orientation */
+#define ABS_MT_POSITION_X   0x35    /* Center X touch position */
+#define ABS_MT_POSITION_Y   0x36    /* Center Y touch position */
+#define ABS_MT_TOOL_TYPE    0x37    /* Type of touching device */
+#define ABS_MT_BLOB_ID      0x38    /* Group a set of packets as a blob */
+#define ABS_MT_TRACKING_ID  0x39    /* Unique ID of initiated contact */
+#define ABS_MT_PRESSURE     0x3a    /* Pressure on contact area */
+#define ABS_MT_DISTANCE     0x3b    /* Contact hover distance */
+#define ABS_MT_TOOL_X       0x3c    /* Center X tool position */
+#define ABS_MT_TOOL_Y       0x3d    /* Center Y tool position */
+
+// Synchronization events
+#define SYN_REPORT      0
+#define SYN_MT_REPORT   2
+
+// Misc events
+#define MSC_TIMESTAMP 0x05
+
 // LED codes
 #define LED_NUML      0x00
 #define LED_CAPSL     0x01
@@ -406,7 +434,8 @@ HIDTabletProbe(
     PINPUT_DEVICE pContext,
     PDYNAMIC_ARRAY pHidDesc,
     PVIRTIO_INPUT_CFG_DATA pAxes,
-    PVIRTIO_INPUT_CFG_DATA pButtons
+    PVIRTIO_INPUT_CFG_DATA pButtons,
+    PVIRTIO_INPUT_CFG_DATA pMisc
 );
 
 NTSTATUS
-- 
2.28.0.windows.1

